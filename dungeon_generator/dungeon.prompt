Your task is to generate a gdscript to produce a randomized graph represented as an adjacency matrix, representing a dungeon layout. The adjacency matrix should be the size of the total number of rooms. If there are no connections between rooms, code 0. Otherwise, the codes 1,2,3,4 represent a top,left,bottom,right edge.

Representations:

Beginning room B
Enemy room E
Loot room L
Shop room S
Final room F

The adjacency matrix columns and rows should represent rooms in the following order:
i = 0: B
n >= i > 0: E
m+n >= i > n: L
i = m+n+1: S
i = m+n+2: F

Valid random dungeon graph rules:

1. Must have only one B, S, F
2. B must have one edge only, and only to an E room
3. F must have one edge only, and only to an E room
4. E must be equal to some number n
5. Graph cannot be linear
6. L must be equal to some number m
7. Should not contain loops
8. F must connect to a E
9. B and F must have the furthest distance in the graph
10. E rooms does not necessarily have to generate in a chain.
11. Generated directions should be randomized.
12. E->L->E and E->S->E rooms are valid, and should be supported, but doesn't have to always generated as so.
13. Do not generate rooms in the same room tile (e.g. E -1-> S -3-> L, which will have E and L both under S)

The script should produce the required structure. Also print out the generated dungeon in the end.

The following is an example of valid dungeon for n = 3, m = 1:

BEEL
ES
F

or represented as a graph:
B (right) E1
E1 (right) E2
E2 (right) L
E1 (down) E3
E3 (right) S
E3 (down) F

---

The following script is the skeleton you are working on. `generate` returns the adjacency matrix of the dungeon digraph with spatial annotations. The adjacency matrix should be the size of the total number of rooms. If there are no connections between rooms, code 0. Otherwise, the codes 1,2,3,4 represent a top,left,bottom,right edge.

Representations:

Beginning room B
Enemy room E
Loot room L
Shop room S
Final room F

The adjacency matrix columns and rows should represent rooms in the following order:
i = 0: B
n >= i > 0: E
m+n >= i > n: L
i = m+n+1: S
i = m+n+2: F

Implement the function `place_rooms` to place pre-defined rooms onto the world Node2D (self), using the previous adjacency matrix as input. Follow the implementation method you suggested.

Use `var scene = PackedScene.instantiate()` to instantiate a scene, and access the following data with `scene.<data_name>`:

```
var dimension : Vector2i (1-based)
var entrances_top : Vector2i (0-based)
var entrances_left : Vector2i
var entrances_bottom : Vector2i
var entrances_right : Vector2i
```

You can place a room onto the world by `call_deferred('add_child', scene)` and move it by setting `scene.position = <position> + self.global_position`

---

```gdscript
extends Node2D

# Room type constants
enum RoomType { B, E, L, S, F }

# Direction codes (from the current room perspective)
const DIR_TOP = 1   # neighbor is at (0,-1)
const DIR_LEFT = 2  # neighbor is at (-1,0)
const DIR_BOTTOM = 3# neighbor is at (0,1)
const DIR_RIGHT = 4 # neighbor is at (1,0)

# Opposite direction mapping (for the reverse connection)
var opposite_direction = {
	DIR_TOP: DIR_BOTTOM,
	DIR_LEFT: DIR_RIGHT,
	DIR_BOTTOM: DIR_TOP,
	DIR_RIGHT: DIR_LEFT,
}

# Direction vectors (and corresponding random label order)
var directions = [
	{"vec": Vector2(0,-1), "code": DIR_TOP},
	{"vec": Vector2(-1,0), "code": DIR_LEFT},
	{"vec": Vector2(0,1),  "code": DIR_BOTTOM},
	{"vec": Vector2(1,0),  "code": DIR_RIGHT}
]

# A room is represented by a dictionary with:
#  id: int
#  pos: Vector2 - grid position
#  neighbors: Array of dictionaries { "id": neighbor_id, "dir": edge_code }
#  type: RoomType (optional at first)
var nodes = []         # List of nodes; index is the room id.
var grid = {}          # Dictionary mapping "x,y" -> room id

func _ready():
	var matrix = generate()


#===============================================================================
# CONSTANTS AND ROOM SCENES
#===============================================================================
const TILE_SIZE := 16
const GAP      := 3 * TILE_SIZE  # minimum pixel gap between rooms

const ROOM_SCENES = {
	RoomType.B: [
		preload("res://scenes/rooms/room_base.tscn"),
	],
	RoomType.E: [
		preload("res://scenes/rooms/room_base.tscn"),
	],
	RoomType.L: [
		preload("res://scenes/rooms/room_base.tscn"),
	],
	RoomType.S: [
		preload("res://scenes/rooms/room_base.tscn"),
	],
	RoomType.F: [
		preload("res://scenes/rooms/room_base.tscn"),
	]
}
```

---

Your task is to implement `draw_corridors`, based on the following gdscript, which already properly handles generating a dungeon graph, and placing the rooms on the world. You can use the two helper functions `_draw_floor` and `_draw_wall` to draw the corridors. The corridors are two wide (so vertical corridors have one more tile to the right of the `get_door_value` door tile corrdinates, and horizontal corridors have one more tile to the bottom of the door tile corrdinates.), and should additionally have walls (so total 4 tiles thick, including walls). Please set a constant `corridor_width`.

The gdscript is as follows:

---

The following gdscript script generates a dungeon graph, and places rooms and draws corridors according to that graph. Your task is to write the functions `draw_minimap` and `update_minimap`, accept the produced `nodes` as input, and use godot's low level `_draw` process to draw the minimap. Assume the functions will not be placed in the provided script.

`draw_minimap` will draw the initial minimap. The minimap works by assuming the player starts at the starting room. It only shows the rooms as well as the neighboring rooms the players has explored. When `update_minimap` is called, a node index is provided, which is the room that the player is currently at, and all the neighboring rooms should be shown.

Instructions on drawing minimap:
1. Maintain relative positions of the rooms specified in `nodes`
2. Display each room as a transparent white square
3. Connect each room with a transparent white line, based on the neighbor directions
4. Each room should also have the room label (B,S,F,L,E) in the square
5. The room the player is at should have 0.9 opacity
6. The rooms the player did explore should have 0.7 opacity
7. The rooms the player hasn't explored, and neighboring the explored rooms, should have 0.3 opacity
8. Corridors should have 0.5 opacity regardless of the connected room's state